# 微前端
## 微前端的价值
- 无技术栈限制：主框架不限制接入应用的技术栈，子应用具备完全自主权
- 独立开发，独立部署，子应用的仓库独立，前后端可独立进行开发，部署完成后主框架自动完成同步更新
- 独立运行时，每个子应用之间状态隔离，运行时状态不共享

## 针对中后台应用的解决方案

微前端架构解决方案大概分成两类场景
- 单实例：即同一时刻，只要一个子应用被展示，子应用具备一个完整的应用生命周期，通常基于url的变化来做子应用的切换
- 多实例：同一时刻可展示多个字应用。通常使用web components方案来做子应用封装，子应用更像是一个业务组件而不是应用。

着重介绍单实例场景下的微前端架构实践方案（基于single-spa），因为这个场景更贴切大部分中后台应用。

## 微前端架构实践中的问题
主框架的定位：导航路由+资源加载框架，而要实现这样一套架构需要解决一些问题

## 路由系统及future state
我们在一个实现了微前端内核的产品中，正常访问一个子应用的页面时，可能会有这样一个链路：

1. 访问 https://app.pay.com 点击导航中的某个子产品的链接
2. https://app.pay.com/subApp subApp渲染并默认redirect到list页面
3. https://app.pay.com/subApp/list 查看列表某一项信息
4. https://app.pay.com/subApp/:id/detail

此时浏览器的地址可能是ttps://app.pay.com/subApp/123/detail ，想象下此时我们手动刷新一下浏览器，会发生什么？

由于我们的自营要都是lazy load的，当浏览器重新刷新时，主框架的资源会被重新加载，同时一步load子应用的静态资源，由于此时主应用的路由系统已经激活，但子应用的资源可能还没有完全加载完毕，从而导致路由注册表里面发现没有能匹配子应用的/subApp/123/detail的规则，这时候会导致条notfound或者直接路由报错

这个问题在所有lazy load方式价值子应用的方案中都会碰到，future state

解决的思路，我们需要设计这样一套路由机制：

主框架配置子路由的路径为：
subApp：{url:'/subAp/**',entry:'./subApp.js'},则当浏览器的地址为/subAp/abc时，框架需要先价值entry资源，待entry资源加载完毕，确保子应用的路由系统注册进框架之后，再去由子应用的路由系统接管url change事件，同时在子应用切出时，主框架需要触发相应的destroy事件，子应用监听到该事件时，调用自己的卸载方法卸载应用

如 React 场景下 destroy = () => ReactDOM.unmountAtNode(container)。

要实现这样一套机制，我们可以自己去劫持url change时间从而实现自己的路由系统，也可以基于社区react-route在v4之后实现的，我们需要复写一部分路由发现逻辑[single-spa](https://github.com/single-spa/single-spa)

## app entry

解决了路由的问题后，主框架和子应用集成的方式，也会成为一个需要关注的技术决策

### 构建时组合 VS 运行时组合
微前端架构模式下，子应用打包的方式由两种

#### 构建时打包：
子应用通过package registry （也可以是npm package） 的方式，与主应用一起打包发布

- 优点：主应用和子应用之间可以做答辩优化，依赖共享

- 缺点：主子应用之间产品工具链耦合，工具链也是技术栈的一部分

#### 运行时打包：
子应用自己构建打包，主应用运行时动态加载子应用资源

- 优点：完全解耦，子应用完全和技术栈无关

- 缺点：多出运行时的复杂度和overhead

要真正实现技术栈无关和独立部署两个目标，大部分场景下需要使用运行时加载的方案。

### js entry VS html entry

js entry ：子应用将资源打成一个entry script，比如single-spa的example中的方式。但是这个方式限制很多，比如要求子应用所以的资源打包到一个js bundle，包括css图片等，除了打包出来的体检庞大，资源的并行价值等特性也无法利用上

html entry： 更加灵活，直接将子应用打出来的html 作用入口，主框架可以通过fetch html的方式获取子应用的静态资源，同时将html document作为子节点塞到主框架的容器中，这样不仅可以极大减少主应用的接入成本，子应用的开发方式和打包方式也基本不用跳转，而且解决子应用之间样式隔离的问题。


